'''
# 문제 이해
연속된 하나 이상의 숫자를 잡고 모두 뒤집는 것
그래서 0과 1로만 이루어진 문자열 s를 모두 같게 만드는 것

# 발상
001100 11001100 1100110011
2번 바뀌면 1번 뒤집고, 3번 바뀌면 2번 뒤집고, 4번 바뀌면 2번 뒤집고, ... ,n번 바뀌면 n-1번 뒤집어야 같아질 수 있다.
다른 경우의 수가 없다.

101100
data 문자열을 입력 받는다.
for 문으로 range(1, len(data))까지 값을 확인한다.
몇 번의 변화가 있는지 비교하며 count한다.
result = count - 1 이다.

# 복잡도
data의 길이가 n일 때 O(n)의 시간복잡도를 가진다.
길이가 100만보다 작으니 시간 제한을 통과할 수 있을 것 같다.
'''
data = input()

count = 0

for i in range(1, len(data)):
    if data[i] != data[i-1]:
        count += 1
    else:
        continue

result = (count + 1) // 2
print(result)

'''
# 푼 시간
13분

# 채점
오답

# 느낀 점
저번에 풀었을 때는 맞았는데 왜 틀렸는지 모르겠다..
앗 발상 부분을 보니 알겠다.
그냥 기록으로 남기고 싶어 주석에서 풀고 있는데 놓치기 너무 쉬운 것들이 많다..
'''